---
description: 
globs: 
alwaysApply: true
---
# Project Overview & Workflow

This is a Go project (`github.com/bmcszk/go-restclient`).

## Development Methodology: Test-Driven Development (TDD)
- Always write tests *before* writing implementation code.
- Ensure tests cover requirements adequately.
- For every task (as defined in `docs/tasks.md`), proceed with TDD principles.

## Documentation
Refer to `.cursor/rules/requirement_workflow.mdc` for guidelines on managing requirements and test scenarios.
Refer to `.cursor/rules/task_workflow.mdc` for guidelines on task creation and management.

1.  **Decisions:** All significant architectural or design decisions must be documented incrementally in `docs/decisions.md`. Include the rationale behind each decision.
2.  **README:** The `README.md` file must be kept up-to-date with the most essential project information, including setup, build, and usage instructions. Update it as the project evolves.
3.  **Date/Time in Documentation:** When the current date or time is needed in any documentation, it must be obtained by running an appropriate command line instruction (e.g., `date +%Y-%m-%d` for date).
4.  **Project Structure Document:** A document outlining the project structure, key components, and their interactions, specifically for the AI assistant\'s understanding and context. This is located at `docs/project_structure.md`.
5.  **Learnings Document:** A document (`docs/learnings.md`) where the AI assistant (you) records any mistakes made during development, along with their resolutions once fixed. This serves as a continuous improvement log.

## Quality Assurance & Workflow
1.  **Pre-commit Checks:** Before committing any code, every change *must* be verified by:
    *   Running the consolidated Makefile target (`make check`). This target will typically include:
        *   Compiling the project (e.g., `go build ./...`)
        *   Running linters (e.g., `golangci-lint run` or other configured linters)
        *   Running all **unit tests** (e.g., `make test-unit` or `go test -tags=unit ./...`)
    *   Running all **End-to-End (E2E) tests** (e.g., `make test-e2e`).
2.  **Makefile Targets for Tools:** All essential development tools used in the project (e.g., `sqlc`, `migrate`, linters) should have corresponding targets in the main `Makefile` for easy and consistent execution.
3.  **Test Coverage:**
    *   Refer to `.cursor/rules/requirement_workflow.mdc` for test coverage guidelines related to requirements and scenarios.
4.  **Task Completion & Version Control:**
    *   Refer to `.cursor/rules/task_workflow.mdc` for guidelines on task completion and version control.

## AI Assistant (You)
- You are expected to adhere to all the above guidelines in every interaction and code modification without being explicitly reminded.
- At the start of processing any request, ensure you are aware of the project\'s root directory (the directory containing the main `Makefile`, usually the workspace root) and the current date (obtain using `date +%Y-%m-%d`).
- When asked to perform a task, ensure all relevant documentation (including the new workflow files) is considered and updated if necessary.
- After making any changes to test files (e.g., refactoring, adding new tests, or modifying existing ones), you **must** run `make check` to ensure all tests pass and the code adheres to quality standards before proceeding with further changes or concluding the task.
- Refer to `.cursor/rules/task_workflow.mdc` for detailed AI assistant responsibilities regarding task processing.
- Refer to `.cursor/rules/requirement_workflow.mdc` for detailed AI assistant responsibilities regarding requirements and test scenarios.
- If you encounter a "file or directory not found" error when attempting to access a path, first check your current working directory using `pwd`, then consult `docs/project_structure.md` to verify the expected location before trying again or reporting an issue.
- **Mistake Logging**: If you make a mistake (e.g., an incorrect code change, a misunderstanding of requirements, a deviation from guidelines), you must:
    1.  Acknowledge the mistake.
    2.  Document the mistake in `docs/learnings.md`, including a brief description of what went wrong.
    3.  Once the mistake is corrected, update the entry in `docs/learnings.md` with the resolution or what was learned.
- **File Editing and Patch Management Strategy**:
    - **Direct File Modification**:
        - Use the `edit_file` tool to make changes *directly* to the target file.
        - The `code_edit` parameter should contain the new or modified lines. Represent unchanged code blocks using the appropriate comment syntax for the language being edited (e.g., `// ... existing code ...` for Go, `<!-- ... existing code ... -->` for XML/HTML, `# ... existing code ...` for Python/Ruby/shell scripts, etc.).
        - Ensure each edit contains sufficient context of unchanged lines around the modified code to resolve ambiguity.
        - For creating new files, provide the entire file content in the `code_edit` field.
    - **Verification and Retries**:
        - After `edit_file` indicates success, use `read_file` to confirm the changes were applied exactly as intended.
        - If the applied diff (shown in the `edit_file` tool's output) is not correct, or if `read_file` shows discrepancies, use the `reapply` tool, targeting the same file, to have the edit attempted again by a more capable model.
        - If `reapply` also fails, or for very complex or widespread changes, break down the modification into several smaller, targeted `edit_file` calls, each focusing on a specific, coherent block of code. Verify each smaller edit before proceeding.
    - **Generating Git Patch Files (When Explicitly Required)**:
        - Patch files should generally *not* be created using `edit_file`.
        - If a Git-formatted patch file is explicitly needed (e.g., for manual review, sharing, or specific Git workflows):
            1.  First, ensure the target file(s) have been successfully modified using the `edit_file` (and `reapply` if needed) and `read_file` verification workflow.
            2.  Stage the modified file(s) using the appropriate Git command (e.g., `git add <file_path>`).
            3.  Then, generate the patch using the correct Git command:
                *   For a diff of staged changes against `HEAD`: `git diff --cached > my_changes.patch`
                *   To create patch files from specific commits (mailbox format): `git format-patch <commit-range/branch> --stdout > my_commit_series.patch` or `git format-patch -1 <commit_sha> -o patches/`
    - **Applying External Git Patch Files**:
        - If you are provided with a patch file to apply:
            1.  First, inspect the patch content if possible (e.g., using `cat patch_file.patch`).
            2.  Check if the patch can be applied cleanly: `git apply --check my_patch.patch`.
            3.  If the patch is a plain diff (usually from `git diff`), apply it to the working directory (changes will be unstaged): `git apply my_patch.patch`.
            4.  If the patch is in mailbox format (from `git format-patch`), apply it and create commits: `git am < my_patch.patch`. Use `git am --abort` to stop a problematic application.
            5.  After applying, always verify the changes and run `make check`.
    - **Avoiding `edit_file` for Patch Creation**: Do not attempt to use `edit_file` to write the *content* of a patch file. `edit_file` is for modifying the *source file itself*.

## Testing Guidelines
- **End-to-End (E2E) / Integration Tests:** These tests verify the behavior of the system as a whole or integrated parts. They should be written in a Behavior-Driven Development (BDD) style using tools like Godog. These tests typically require a running instance of the application and its dependencies (like databases) managed via Docker Compose. Use Go build tags (e.g., `//go:build e2e`) to identify them.
- **E2E tests MUST strive to cover all functional requirements outlined in `docs/requirements.md` and all scenarios listed in `docs/test_scenarios.md`, ensuring key user flows and API interactions are validated against a realistic (Dockerized) environment.**
- Both unit and E2E tests MUST be runnable via dedicated Makefile targets (e.g., `make test-unit`, `make test-e2e`).
