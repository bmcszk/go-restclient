---
description: 
globs: 
alwaysApply: true
---
# Project Overview & Workflow (AI-Readable)

Project: Go library `github.com/bmcszk/go-restclient`.

## 1. Development Methodology: TDD
    - ALWAYS write tests BEFORE implementation.
    - Ensure tests cover requirements adequately.
    - APPLY TDD for all tasks in `docs/tasks.md`.

## 2. Documentation Rules
    - Requirement/Scenario Guidelines: See `.cursor/rules/requirement_workflow.mdc`.
    - Task Guidelines: See `.cursor/rules/task_workflow.mdc`.
    - **Decisions (`docs/decisions.md`):** Incrementally document ALL significant architectural/design decisions with rationale.
    - **README (`README.md`):** Keep up-to-date with essential project info (setup, build, usage). Update as project evolves.
    - **Date/Time in Docs:** For current date/time, USE shell command (e.g., `date +%Y-%m-%d`).
    - **Project Structure (`docs/project_structure.md`):** This outlines project structure for AI understanding.
    - **Learnings (`docs/learnings.md`):** Record AI mistakes and their resolutions here for continuous improvement.
    - **Project Scope Confirmation**: BEFORE detailed setup, CONFIRM high-level project goal & type (e.g., service vs. library). Clarify if general guidelines apply fully or need adaptation.

## 3. Quality Assurance & Workflow
    - **Pre-commit Checks (MANDATORY):** BEFORE committing, VERIFY ALL changes by:
        1. Running `make check` (includes compile, lint, all unit tests).
    - **Makefile Targets for Tools:** ENSURE all essential dev tools (sqlc, migrate, linters) have Makefile targets.
    - **Test Coverage:** See `.cursor/rules/requirement_workflow.mdc`.
    - **Task Completion & VC:** See `.cursor/rules/task_workflow.mdc`.
    - **Procedural Integrity**: ENSURE directory structures are planned/created BEFORE files within them (esp. for automation).
    - **Trust `make check`**: TREAT `make check` results as definitive. If tests fail, code is faulty. DO NOT mark tasks Done if tests fail.

## 4. AI Assistant (You) Responsibilities
    - ADHERE to ALL guidelines herein without explicit reminder.
    - **Initial Context:** At request start, CONFIRM project root (main `Makefile` dir) & current date (`date +%Y-%m-%d`).
    - **Documentation Awareness:** When performing tasks, CONSIDER and UPDATE ALL relevant docs (requirements, scenarios, tasks, decisions, README, project_structure, learnings, workflow files).
    - **Post-Test File Change:** After ANY change to test files (add, refactor, modify), YOU MUST run `make check`. PROCEED only if all tests pass & quality standards met.
    - **Task Processing:** See `.cursor/rules/task_workflow.mdc`.
    - **Requirements/Scenarios:** See `.cursor/rules/requirement_workflow.mdc`.
    - **File Not Found Error:** If path error, 1) `pwd`, 2) consult `docs/project_structure.md`, 3) retry or report.
    - **Clarify Ambiguity**: If requirements/terms are ambiguous (multiple interpretations, libraries, patterns), explicitly CONFIRM intended approach.
    - **Mistake Logging (`docs/learnings.md`):**
        1. Acknowledge mistake.
        2. Document mistake in `docs/learnings.md` (what went wrong).
        3. After correction, UPDATE `docs/learnings.md` with resolution/lesson.
    - **Problem Solving Strategy:** If stuck on a task (e.g., tool limitations, persistent errors):
        1. Re-consult all relevant project guidelines and documentation (`.mdc` files, `docs/` folder).
        2. If guidelines do not provide a path forward, perform a web search for potential solutions or workarounds. Prefix search queries with "cursor ai" to tailor results (e.g., "cursor ai golang edit_file not applying changes").
        3. If still unable to resolve, clearly document the issue, attempted steps, and why progress is blocked, then await user guidance.

## 5. File Editing & Patch Management (AI Agent)
    - **A. Direct File Modification (`edit_file` tool):**
        - USE `edit_file` for direct changes.
        - `code_edit`: New/modified lines. Unchanged code: `// ... existing code ...` (adapt comment style to language).
        - PROVIDE sufficient context (unchanged lines around edit) to avoid ambiguity.
        - New files: `code_edit` contains entire file content.
    - **B. Verification & Retries:**
        - AFTER `edit_file` success, USE `read_file` to confirm exact application.
        - CAUTION: `edit_file` success report DOES NOT guarantee disk write visible to `git` or auto-staging. ALWAYS verify file changes & Git status.
        - If `edit_file` diff incorrect OR `read_file` shows discrepancies, USE `reapply` (same file).
        - If `reapply` fails OR for complex/widespread changes: Break into SMALLER, targeted `edit_file` calls. VERIFY each.
    - **C. `edit_file` Tool - CRITICAL CAUTIONS & LIMITATIONS:**
        - **Risk of Corruption (HIGH):** `edit_file` can be DANGEROUS with inconsistent file states or large/complex diffs. May misinterpret context, causing SEVERE file corruption. SAFER: Manual intervention or VCS restore. USE EXTREME CAUTION beyond simple, localized changes, especially if prior edits unreliable.
        - **Subtlety Issues:** May struggle with subtle changes (e.g., single trailing space removal, precise whitespace/newline in test data). May not register/apply correctly.
        - **Markdown/Tables:** Unreliable for complex Markdown updates (esp. tables).
        - **Patch Generation:** May have issues generating patch diffs correctly.
        - **Verification is KEY:** ALWAYS verify `edit_file` results (`read_file`), esp. for critical files or subtle changes. If tool repeatedly problematic, seek alternatives/manual help.
        - **Accidental Deletions:** Tool can misapply diffs, causing accidental content deletion. Review diff & `read_file` output carefully.
    - **D. Generating Git Patches (ONLY When Explicitly Required):**
        - General Rule: DO NOT use `edit_file` to create patch files.
        - If Git-formatted patch NEEDED (manual review, sharing, specific Git workflows):
            1. ENSURE target file(s) correctly modified via `edit_file`/`reapply`/`read_file` workflow.
            2. Stage file(s): `git add <file_path>`.
            3. Generate patch (Git commands):
                - Staged vs. HEAD: `git diff --cached > my_changes.patch`
                - From commits (mailbox): `git format-patch <commit-range/branch> --stdout > series.patch` OR `git format-patch -1 <sha> -o patches/`
    - **E. Applying External Git Patches:**
        1. Inspect patch: `cat patch_file.patch` (if possible).
        2. Check applicability: `git apply --check my_patch.patch`.
        3. Plain diff (`git diff`): `git apply my_patch.patch` (changes unstaged).
        4. Mailbox format (`git format-patch`): `git am < my_patch.patch` (creates commits). Use `git am --abort` on issues.
        5. ALWAYS verify changes & run `make check` post-application.
    - **F. `edit_file` for Patch CONTENT: AVOID.** `edit_file` modifies source files, not for writing patch content.
    - **G. Handling Problematic Large File Edits / Complex Refactors:**
        - If `edit_file` or `reapply` consistently fails or produces incorrect diffs for a large file or complex refactoring task across multiple locations:
            1. **Identify Problematic File(s):** Note the specific file(s) causing issues.
            2. **Reject Changes:** Ensure no partial/corrupt changes from failed attempts are staged or kept.
            3. **Reset File(s):** Use `git checkout -- <file_path>` or `git restore <file_path>` to revert the problematic file(s) to their last committed state (HEAD).
            4. **Strategize Refactoring (If Applicable):** If the issue is due to complexity (e.g., refactoring a large function/struct used in many places):
                - Consider if the large file/struct can be broken down into smaller, more manageable, and independently modifiable units/files. This might be a separate preliminary task.
                - If splitting is feasible, propose and (if approved or per autonomy rules) perform the split first.
            5. **Re-attempt Task on Smaller Units:** If files were split, or if the original task can be broken into smaller, more localized edits on the original file, attempt these smaller edits sequentially, verifying each with `read_file` and `make check` (if applicable) before proceeding.
            6. **Manual Intervention**: If automated edits on smaller chunks still fail, or if splitting the file is not feasible/desired, explicitly state that the task requires manual intervention due to tool limitations with the specific file/complexity.

## 6. Testing Guidelines (Project Specific)
    - **Test Coverage:** MUST cover all functional requirements (`docs/requirements.md`) and scenarios (`docs/test_scenarios.md`). Validate key user flows & API interactions in realistic (Dockerized) environment.
    - **Makefile Targets:** Unit tests MUST be runnable via `make test-unit`.
