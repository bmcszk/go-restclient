package test

import (
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"text/template"

	"github.com/stretchr/testify/require"
)

// PRD-COMMENT: TEST_HELPER_DEBUG_LOGGING - Test Utility: createTestFileFromTemplate Debug Output
// Corresponds to: Verifying the diagnostic logging capabilities of the
// `createTestFileFromTemplate` test helper function. This function is essential for
// preparing `.http` request files from templates for various tests.
// This test executes `createTestFileFromTemplate` using
// 'test/data/http_request_files/system_var_datetime.http' as a template and observes the
// `t.Logf` output generated by the helper, ensuring it provides useful debugging information
// during test execution and setup.
func RunCreateTestFileFromTemplate_DebugOutput(t *testing.T) {
	t.Helper()
	templateFileName := "system_var_datetime.http"
	wd, err := os.Getwd()
	require.NoError(t, err, "Failed to get working directory")
	templatePath := filepath.Join(wd, "test/data", "http_request_files", templateFileName)

	// Check if the source template file exists
	_, err = os.Stat(templatePath)
	require.NoError(t, err, "Source template file %s does not exist", templatePath)

	t.Logf("Attempting to process template: %s", templatePath)

	data := struct{ ServerURL string }{ServerURL: "http://localhost:12345/mockserver"}

	// Call the function under test
	// The t.Logf calls inside createTestFileFromTemplate should execute here
	processedFilePath := createTestFileFromTemplate(t, templatePath, data)
	require.NotEmpty(t, processedFilePath, "createTestFileFromTemplate returned an empty path")

	// Clean up the created temporary file
	// We do this even if the test fails to ensure no lingering temp files
	// if the test requires the file to exist for further checks, this should be deferred or handled differently.
	// For this specific debug test, we just want to see the logs from createTestFileFromTemplate.
	defer func() {
		errRemove := os.Remove(processedFilePath)
		if errRemove != nil {
			t.Logf("Warning: failed to remove temporary file %s: %v", processedFilePath, errRemove)
		}
	}()

	t.Logf("TestCreateTestFileFromTemplate_DebugOutput completed. Processed file was: %s", processedFilePath)
	// No specific assertions needed here, the goal is to observe t.Logf output from the helper.
}


// Helper to create a mock server
func startMockServer(handler http.HandlerFunc) *httptest.Server {
	return httptest.NewServer(handler)
}

// createTestFileFromTemplate processes a template file and returns the path to the processed file.
func createTestFileFromTemplate(t *testing.T, templatePath string, data any) string {
	t.Helper()
	tmplContent, err := os.ReadFile(templatePath)
	require.NoError(t, err)

	t.Logf("[DEBUG_CREATE_TEST_FILE] Original template content for %s:\n%s", templatePath, string(tmplContent))

	// Use different delimiters to avoid conflict with {{...}} used by the library itself
	tmpl, err := template.New("testfile").Delims("[[", "]]").Parse(string(tmplContent))
	require.NoError(t, err)

	tempFile, err := os.CreateTemp(t.TempDir(), "processed_*.http")
	require.NoError(t, err)
	tempFileName := tempFile.Name() // Get name before closing for reliable access

	err = tmpl.Execute(tempFile, data)
	require.NoError(t, err)

	err = tempFile.Close()
	require.NoError(t, err)

	// Read back the content of the temporary file to log what was actually written
	writtenContent, readErr := os.ReadFile(tempFileName)
	require.NoError(t, readErr, "Failed to read back temp file for debugging: %s", tempFileName)
	t.Logf("[DEBUG_CREATE_TEST_FILE] Content written to temp file %s:\n%s", tempFileName, string(writtenContent))

	return tempFileName
}

// mockRoundTripper is a helper for mocking http.RoundTripper
type mockRoundTripper struct {
	RoundTripFunc func(req *http.Request) (*http.Response, error)
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	if m.RoundTripFunc != nil {
		return m.RoundTripFunc(req)
	}
	return nil, errors.New("RoundTripFunc not set")
}


// parseHrespBody reads an .hresp file and parses its content to separate
// headers and body. It returns the parsed headers as http.Header and the body as a string.
// The .hresp format expects headers first, then a blank line, then the body.
func parseHrespBody(filePath string) (http.Header, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read .hresp file %s: %w", filePath, err)
	}

	parts := strings.SplitN(string(content), "\n\n", 2)
	headers := make(http.Header)

	headerLines := strings.Split(strings.TrimSpace(parts[0]), "\n")
	for _, line := range headerLines {
		if strings.TrimSpace(line) == "" || !strings.Contains(line, ":") {
			// Skip empty lines or lines not containing a colon (likely the HTTP version line or status)
			continue
		}
		headerParts := strings.SplitN(line, ":", 2)
		if len(headerParts) == 2 {
			headers.Add(strings.TrimSpace(headerParts[0]), strings.TrimSpace(headerParts[1]))
		}
	}

	// The body part (parts[1]) is intentionally ignored as it's not used by callers.
	return headers, nil
}
